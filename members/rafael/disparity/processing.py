from .pair_selector import PairCandidate
import os
import subprocess
import numpy as np
import scipy.ndimage

from .constants import (
    ASP_BIN_PATH,
    MARGIN_UNDEFINED
)

def run_asp_tool(tool_name, args):
    tool_path = os.path.join(ASP_BIN_PATH, tool_name)
    env = os.environ.copy()
    env["PATH"] = f"{ASP_BIN_PATH}:{env['PATH']}"
    
    print(f"############## Executing: {tool_path} {' '.join(args)}")
    return subprocess.run([tool_path] + args, env=env, check=True)


def normalise_image(image, nb=8):
    image = image.astype(float)
    im_defined = image >= 0
    median_value = np.median(image[im_defined])
    image -= median_value
    median_distance = np.median(np.abs(image[im_defined]))
    image /= median_distance * nb
    image[image < -1] = -1
    image[image > 1] = 1
    image += 1
    image /= 2
    image[np.logical_not(im_defined)] = -1
    return image

def post_process_undefined(undefined, max_disp):
    undefined[:,0] = True
    undefined[:,-1] = True
    undefined[0, :] = True
    undefined[-1, :] = True
    undefined = scipy.ndimage.binary_dilation(undefined, iterations=MARGIN_UNDEFINED)
    return undefined

def warp_coordinates(Xfrom, Yfrom, mat, width, height):
    X = np.round(mat[0,0] * Xfrom + mat[0,1] * Yfrom + mat[0,2]).astype('int')
    Y = np.round(mat[1,0] * Xfrom + mat[1,1] * Yfrom + mat[1,2]).astype('int')
    
    coordinates_to_keep = np.ones(X.shape, dtype=bool)
    coordinates_to_keep[X < 0] = False
    coordinates_to_keep[Y < 0] = False
    coordinates_to_keep[X >= width] = False
    coordinates_to_keep[Y >= height] = False
    
    X = X[coordinates_to_keep]
    Y = Y[coordinates_to_keep]
    Xfrom = Xfrom[coordinates_to_keep]
    Yfrom = Yfrom[coordinates_to_keep]
    
    return X, Y, Xfrom, Yfrom


def generate_rectified(pair: PairCandidate, pair_id, tmp_stereo_output_path, use_bundle_adjust=False):

    pair_path = os.path.join(tmp_stereo_output_path, str(pair_id))
    os.makedirs(pair_path, exist_ok=True)
    out_path = os.path.join(pair_path, 'results', 'out')
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
    # Run stereo with stop-point=1 (rectification only)
    print(pair.img1.cropped_path)
    print(pair.img2.cropped_path)
    print(pair.img1.cropped_name)
    print(pair.img2.cropped_name)
    args = ['-t', 'rpc', '--stop-point=1'] + \
        [os.path.join(pair.img1.cropped_path, pair.img1.cropped_name), \
        os.path.join(pair.img2.cropped_path, pair.img2.cropped_name)] + [out_path]
    
    run_asp_tool('stereo', args)
    
    if not os.path.exists(out_path + '-L.tif') and os.path.exists(out_path + '-R.tif'):
        raise ValueError("ERROR - no rectified images generated by ASP")
    
    pair.rectified_pair_path = out_path
    return out_path

# TODO: Compare results with the whole AMS pipeline running
def generate_pc_from_pair(pair, pair_id, tmp_stereo_output_path, use_bundle_adjust=False):
    pre_path = os.path.join(tmp_stereo_output_path, str(pair_id), 'results', 'out')
    
    args = ['-t', 'rpc', '-e', '4'] + pair + [pre_path]
    
    run_asp_tool('stereo', args)


def photoconsistency_map(left, right, left_disp, min_disp):
    consistency_mat = np.zeros(left_disp.shape)
    nb_positions = left_disp.shape[0] * left_disp.shape[1]
    positions = np.arange(nb_positions)
    xs = (positions % left_disp.shape[1]).astype(int)
    ys = (positions // left_disp.shape[1]).astype(int)

    reshaped_left_disp = left_disp.reshape(nb_positions)
    disp_xs = np.round(xs - reshaped_left_disp).astype(int)
    undefined_values = np.logical_or(
        np.logical_or(np.logical_or(np.isnan(reshaped_left_disp), disp_xs < 0),
                      disp_xs >= left_disp.shape[1]),
        reshaped_left_disp < min_disp
    )
    disp_xs[undefined_values] = xs[undefined_values]

    diff = np.abs(right[ys, disp_xs].astype(float) - left[ys, xs].astype(float)) / 255.0
    diff[undefined_values] = 0

    consistency_mat[ys, xs] = diff

    return consistency_mat


def add_margin(image, margin, val=0):
    t_im_np = np.zeros((image.shape[0], image.shape[1] + margin * 2), dtype=image.dtype)
    t_im_np[:,:] = val
    t_im_np[:, margin:-margin] = image
    return t_im_np


def remove_margin(image, margin):
    return image[:, margin:-margin]
